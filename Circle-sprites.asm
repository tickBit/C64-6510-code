    
        ; BASIC SYS line (start in basic with "sys 49152")
        * = $c000

        sei

        lda #255
        sta 53248+21

        ldx #0
loop1   lda spriteData,x
        sta 12288,x
        inx
        cpx #63
        bne loop1
	
        ldx #0
loop2   lda #1
        sta 53248+39,x
        lda #192
        sta 2040,x
        inx
        cpx #8
        bne loop2

        ; raster inerrupt: https://codebase.c64.org/doku.php?id=base:introduction_to_raster_irqs

        sei        ;disable maskable IRQs

        lda #$7f
        sta $dc0d   ;disable timer interrupts which can be generated by the two CIA chips
        sta $dd0d   ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
                    ;stop it.

        lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.
        lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
                    ;we don't want that to happen.

        lda #$01   ;this is how to tell the VICII to generate a raster interrupt
        sta $d01a

        lda #$20   ;this is how to tell at which rasterline we want the irq to be triggered
        sta $d012

        lda #$1b   ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as
        sta $d011  ;the 9th bit for the rasterline we want our irq to be triggered.
                    ;here we simply set up a character screen, leaving the topmost bit 0.

        lda #$35   ;we turn off the BASIC and KERNAL rom here
        sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
                    ;SID/VICII/etc are visible

        lda #<movesprites  ;this is how we set up
        sta $fffe  ;the address of our interrupt code
        lda #>movesprites
        sta $ffff

        cli        ;enable maskable interrupts again
inf     jmp        inf
	    rts

movesprites
        lda #$ff    ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.
        sta $d019   ;if you don't do this the interrupt condition will be present all the time and you end
                    ;up having the CPU running the interrupt code all the time, as when it exists the
                    ;interrupt, the interrupt request from the VICII will be there again regardless of the
                    ;rasterline counter.        
        
        lda xsinus,x
        sta $d000
        lda ysinus,y
        sta $d001

        lda #9-1
        sta cntr
loop5   inx
        inx
        inx
        inx
        iny
        iny
        iny
        iny
        dec cntr
        bne loop5

        lda xsinus,x
        sta $d002
        lda ysinus,y
        sta $d003

        lda #9-1
        sta cntr
loop6   inx
        inx
        inx
        inx
        iny
        iny
        iny
        iny
        dec cntr
        bne loop6

        lda xsinus,x
        sta $d004
        lda ysinus,y
        sta $d005

        lda #9-1
        sta cntr
loop7   inx
        inx
        inx
        inx
        iny
        iny
        iny
        iny
        dec cntr
        bne loop7

        lda xsinus,x
        sta $d006
        lda ysinus,y
        sta $d007

        lda #9-1
        sta cntr
loop8   inx
        inx
        inx
        inx
        iny
        iny
        iny
        iny
        dec cntr
        bne loop8

        lda xsinus,x
        sta $d008
        lda ysinus,y
        sta $d009

        lda #9-1
        sta cntr
loop9   inx
        inx
        inx
        inx
        iny
        iny
        iny
        iny
        dec cntr
        bne loop9

        lda xsinus,x
        sta $d00a
        lda ysinus,y
        sta $d00b

        lda #9-1
        sta cntr
loop10  inx
        inx
        inx
        inx
        iny
        iny
        iny
        iny
        dec cntr
        bne loop10

        lda xsinus,x
        sta $d00c
        lda ysinus,y
        sta $d00d

        lda #9-1
        sta cntr
loop11  inx
        inx
        inx
        inx
        iny
        iny
        iny
        iny
        dec cntr
        bne loop11

        lda xsinus,x
        sta $d00e
        lda ysinus,y
        sta $d00f

        lda #28*8-1
        sta cntr
loop12  dex
        dey
        dec cntr
        bne loop12
        
        rti


spriteData:

.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $38
.byte   $00
.byte   $00
.byte   $7c
.byte   $00
.byte   $00
.byte   $f6
.byte   $00
.byte   $00
.byte   $fa
.byte   $00
.byte   $00
.byte   $fa
.byte   $00
.byte   $00
.byte   $fe
.byte   $00
.byte   $00
.byte   $7c
.byte   $00
.byte   $00
.byte   $38
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00
.byte   $00

cntr            .byte 0

xsinus:         .byte 128 + 64 * cos(range(0, 360, 1.25) * rad(360.0/256.0))
ysinus:         .byte 128 + 64 * sin(range(0, 360, 1.25) * rad(360.0/256.0))